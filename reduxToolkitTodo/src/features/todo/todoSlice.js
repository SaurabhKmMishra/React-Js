import {createSlice, nanoid} from '@reduxjs/toolkit'
import { react } from 'react'

// 'nanoid' is a method which generates unique ids.

            // initial state for slice

const initialState = {
    todos: [{id:1, text:"Hello world "}],
    editingId: null,
}




                // Create a slice


export const todoSlice = createSlice({

    name: 'todo',
    initialState,
    reducers: { // reducers contains properties and functions
        addTodo: (state, action) => {
            const todo = {
                id: nanoid(),
                text: action.payload
            }
            state.todos.push(todo)
            // above since we have state access so we can push inside it, the new updates.
            // unlike the case in contextApi where first we destructure all the array values then store in them the update and again save to the state var.
            // but since here we have states in a kind of preserved cndn. so we can directly push in the variable directly.
        }, 
        removeTodo: (state, action) => {       
            state.todos = state.todos.filter((todo)=> (todo.id !== action.payload)) // overriding the todos

            if(state.editingId === action.payload) state.editingId = null;
        },
        updateTodo: (state, action) => {
            const todo = state.todos.find(todo => todo.id === action.payload.id)
            todo.text = action.payload.text

            state.editingId = null  // reset after update

        },
        setEditing: (state, action) => {
            state.editingId = action.payload // id or null
        }

    }
    
})


export const {addTodo, removeTodo, updateTodo,setEditing} = todoSlice.actions //named export

export default todoSlice.reducer //default export

/* :> Remember we need to export the reducers in two parts.

   :> Firstly we'll export all the functionality(like: removeTodo, updateTodo) individually of the reducer because the state will be updated using individual of them only. 

   :> Secondly the store too needs to be aware with the reducers, to update further b/c of it's restriction to only update from the data in registered reducers in it. So that's why it needs the list of all reducers. So we secondly export all reducers to the store.

   :> In Redux Toolkit, slice.actions is simply a collection of action creator functions that RTK generates for you from the reducers you define in a slice.


*/



/*  
    :> in RTK what the thing is that we need to deal with four things i.e, store, reducers, useDispatch(), useSelector(). 

    :> the initialState is an important thing in a store. It can be an empty array/obj or anything you want, it determines how will be the store initially.

    :> Every Slice has an initial State some times it can be declared using colon in the createSlice obj. or declared outside and used like above.

    :> After adding name property and initialState comes the reducers which contains properties and functions.

    :> Here comes the actual diff. from context API bcs there we were just declaring the function but here we'll define them as well.

    :> Also in the function inside the reducer we have access to two things: state, action.

    :> 'state' variable Represents the current state of that slice. While 'action' is an object that describes what happened, and may carry data needed to update the state.

    :> also action has two main fields:

        1. type (auto-generated by RTK)
        2. payload (data sent to the reducer) and it is a obj. which can contain several data in it.

    :> also more precisely : 

        1. action.type → what happened (e.g. "counter/incrementByAmount")

        2. action.payload → the data needed to act on it   

    
*/


