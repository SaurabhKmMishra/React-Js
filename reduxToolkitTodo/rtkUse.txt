1. Every Application has a single store viz. known as "Single source of truth"

2. Inside that we need a configureStore() to configure the store. And this configureStore could have multiple properties.

3. we needs to store all of the reducers in the store, b/c without that it can't utilize the data into states b/c it is not the part of the data flow.

4. so that's why we goes inside the features to which we call as slice in docs and made slice using createSlice.

5. Also, to make a slice we needs three things majorly viz. name, initial State and reducers. 

6. so, in intitalState we defines the initial state of the slice variable using any dtastructure like array/obj etc.
 

:> in RTK what the thing is that we need to deal with four things i.e, store, reducers, useDispatch(), useSelector(). 

:> the initialState is an important thing in a store. It can be an empty array/obj or anything you want, it determines how will be the store initially.

:> Every Slice has an initial State some times it can be declared using colon in the createSlice obj. or declared outside and used like above.

:> After adding name property and initialState comes the reducers which contains properties and functions.

:> Here comes the actual diff. from context API bcs there we were just declaring the function but here we'll define them as well.

:> Also in the function inside the reducer we have access to two things: state, action.

:> 'state' variable Represents the current state of that slice. While 'action' is an object that describes what happened, and may carry data needed to update the state.

:> also action has two main fields:

    1. type (auto-generated by RTK)
    2. payload (data sent to the reducer) and it is a obj. which can contain several data in it.

:> also more precisely : 

    1. action.type → what happened (e.g. "counter/incrementByAmount")

    2. action.payload → the data needed to act on it   


**important 
    ✅In RTK reducers, we can write push/update directly because Immer wraps the state in a draft and turns those mutations into a new immutable state behind the scenes. So the code looks mutable, but Redux still gets an immutable update.

    ✅In Context/useState, the state you receive is the real state, so you must create and return a new copy yourself. React does not track mutations, it only detects new references.


:> Now comes the exporting part of the reducers viz. in two steps:
i.e, 

   (1). Exporting individual reducers/features bcs we don't know where or in which component their use may be required.   

   (2). Secondly, we need to export the main source of all of the reducers as it will be required in store.


:> Now in our components we uses useDispatch() and an imported reducer inside it to sent the values to the store using it. 

:> also, we uses useSelector() to get values form the store as this method has aaccess to the state of the store in a callback.

